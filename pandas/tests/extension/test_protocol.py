from pandas.core.arrays import ExtensionArray


class ProtocolImplementingClass:
    _typ = ...
    __pandas_priority__ = ...
    __hash__ = ...

    @classmethod
    def _from_sequence(cls, scalars, *, dtype, copy):
        ...

    @classmethod
    def _from_scalars(cls, scalars, *, dtype, copy):
        ...

    @classmethod
    def _from_sequence_of_strings(cls, strings, *, dtype, copy):
        ...

    @classmethod
    def _from_factorized(cls, values, original):
        ...

    def __getitem__(self, item):
        ...

    def __setitem__(self, key, value):
        ...

    def __len__(self):
        ...

    def __iter__(self):
        ...

    def __contains__(self, item):
        ...

    def __eq__(self, other):
        ...

    def __ne__(self, other):
        ...

    def to_numpy(self, dtype, copy, na_value):
        ...

    @property
    def dtype(self):
        ...

    @property
    def shape(self):
        ...

    @property
    def size(self):
        ...

    @property
    def ndim(self):
        ...

    @property
    def nbytes(self):
        ...

    def astype(self, dtype, copy):
        ...

    def isna(self):
        ...

    @property
    def _hasna(self):
        ...

    def _values_for_argsort(self):
        ...

    def argsort(self, *, ascending, kind, na_position, **kwargs):
        ...

    def argmin(self, skipna):
        ...

    def argmax(self, skipna):
        ...

    def interpolate(
        self, *, method, axis, index, limit, limit_direction, limit_area, copy, **kwargs
    ):
        ...

    def _pad_or_backfill(self, *, method, limit, limit_area, copy):
        ...

    def fillna(self, value, method, limit, copy):
        ...

    def dropna(self):
        ...

    def duplicated(self, keep):
        ...

    def shift(self, periods, fill_value):
        ...

    def unique(self):
        ...

    def searchsorted(self, value, side, sorter):
        ...

    def equals(self, other):
        ...

    def isin(self, values):
        ...

    def _values_for_factorize(self):
        ...

    def factorize(self, use_na_sentintel):
        ...

    def repeat(self, repeats, axis):
        ...

    def take(self, indices, *, allow_fill, fill_value):
        ...

    def copy(self):
        ...

    def view(self, dtype):
        ...

    def __repr__(self):
        ...

    def _get_repr_footer(self):
        ...

    def _repr_2d(self):
        ...

    def _formatter(self, boxed):
        ...

    def transpose(self, *axes):
        ...

    @property
    def T(self):
        ...

    def ravel(self, order):
        ...

    @classmethod
    def _concat_same_type(cls, to_concat):
        ...

    @property
    def _can_hold_na(self):
        ...

    def _accumulate(self, name, *, skipna, **kwargs):
        ...

    def _reduce(self, name, *, skipna, keepdims, **kwargs):
        ...

    def _values_for_json(self):
        ...

    def _hash_pandas_object(self, *, encoding, hash_key, categorize):
        ...

    def _explode(self):
        ...

    def tolist(self):
        ...

    def delete(self, loc):
        ...

    def insert(self, loc, item):
        ...

    def _putmask(self, mask, value):
        ...

    def _where(self, mask, value):
        ...

    def _fill_mask_inplace(self, method, limit, mask):
        ...

    def _rank(self, *, axis, method, na_option, ascending, pct):
        ...

    @classmethod
    def _empty(cls, shape, dtype):
        ...

    def _quantile(self, qs, interpolation):
        ...

    def _mode(self, dropna):
        ...

    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
        ...

    def map(self, mapper, na_action):
        ...

    def _groupby_op(self, *, how, has_dropped_na, min_count, ngroups, ids, **kwargs):
        ...


def test_structural_subtyping_instance_check():
    assert isinstance(ProtocolImplementingClass(), ExtensionArray)
