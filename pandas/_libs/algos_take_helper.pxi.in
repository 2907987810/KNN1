"""
Template for each `dtype` helper function for take

WARNING: DO NOT edit .pxi FILE directly, .pxi is generated from .pxi.in
"""

#----------------------------------------------------------------------
# take_1d, take_2d
#----------------------------------------------------------------------

{{py:

# name, dest, c_type_in, c_type_out, preval, postval, can_copy, nogil
dtypes = [
    ('bool', 'bool', 'uint8_t', 'uint8_t', '', '', True, True),
    ('bool', 'object', 'uint8_t', 'object',
     'True if ', ' > 0 else False', False, False),
    ('int8', 'int8', 'int8_t', 'int8_t', '', '', True, False),
    ('int8', 'int32', 'int8_t', 'int32_t', '', '', False, True),
    ('int8', 'int64', 'int8_t', 'int64_t', '', '', False, True),
    ('int8', 'float64', 'int8_t', 'float64_t', '', '', False, True),
    ('int16', 'int16', 'int16_t', 'int16_t', '', '', True, True),
    ('int16', 'int32', 'int16_t', 'int32_t', '', '', False, True),
    ('int16', 'int64', 'int16_t', 'int64_t', '', '', False, True),
    ('int16', 'float64', 'int16_t', 'float64_t', '', '', False, True),
    ('int32', 'int32', 'int32_t', 'int32_t', '', '', True, True),
    ('int32', 'int64', 'int32_t', 'int64_t', '', '', False, True),
    ('int32', 'float64', 'int32_t', 'float64_t', '', '', False, True),
    ('int64', 'int64', 'int64_t', 'int64_t', '', '', True, True),
    ('int64', 'float64', 'int64_t', 'float64_t', '', '', False, True),
    ('float32', 'float32', 'float32_t', 'float32_t', '', '', True, True),
    ('float32', 'float64', 'float32_t', 'float64_t', '', '', False, True),
    ('float64', 'float64', 'float64_t', 'float64_t', '', '', True, True),
    ('object', 'object', 'object', 'object', '', '', False, False)]


def get_dispatch(dtypes):

    for (name, dest, c_type_in, c_type_out, preval, postval,
         can_copy, nogil) in dtypes:
        if nogil:
            nogil_str = "with nogil:"
            tab = '    '
        else:
            nogil_str = ''
            tab = ''

        yield (name, dest, c_type_in, c_type_out, preval, postval, can_copy,
               nogil_str, tab)

}}


{{for name, dest, c_type_in, c_type_out, preval, postval, can_copy,
      nogil_str, tab
      in get_dispatch(dtypes)}}


@cython.wraparound(False)
@cython.boundscheck(False)
def take_1d_{{name}}_{{dest}}({{if c_type_in != 'object'}}const{{endif}} {{c_type_in}}[:] values,
                              const int64_t[:] indexer,
                              {{c_type_out}}[:] out,
                              fill_value=np.nan):
    cdef:
        Py_ssize_t i, n, idx
        {{c_type_out}} fv

    n = indexer.shape[0]

    fv = fill_value

    {{nogil_str}}
    {{tab}}for i from 0 <= i < n:
    {{tab}}    idx = indexer[i]
    {{tab}}    if idx == -1:
    {{tab}}        out[i] = fv
    {{tab}}    else:
    {{tab}}        out[i] = {{preval}}values[idx]{{postval}}


@cython.wraparound(False)
@cython.boundscheck(False)
def take_2d_axis0_{{name}}_{{dest}}({{if c_type_in != 'object'}}const{{endif}} {{c_type_in}}[:, :] values,
                                    const int64_t[:] indexer,
                                    {{c_type_out}}[:, :] out,
                                    fill_value=np.nan):
    cdef:
        Py_ssize_t i, j, k, n, idx
        {{c_type_out}} fv

    n = len(indexer)
    k = values.shape[1]

    fv = fill_value

    {{if can_copy}}
    cdef:
        {{c_type_out}} *v
        {{c_type_out}} *o

    #GH3130
    if (values.strides[1] == out.strides[1] and
        values.strides[1] == sizeof({{c_type_out}}) and
        sizeof({{c_type_out}}) * n >= 256):

        for i from 0 <= i < n:
            idx = indexer[i]
            if idx == -1:
                for j from 0 <= j < k:
                    out[i, j] = fv
            else:
                v = &values[idx, 0]
                o = &out[i, 0]
                memmove(o, v, <size_t>(sizeof({{c_type_out}}) * k))
        return
    {{endif}}

    for i from 0 <= i < n:
        idx = indexer[i]
        if idx == -1:
            for j from 0 <= j < k:
                out[i, j] = fv
        else:
            for j from 0 <= j < k:
                out[i, j] = {{preval}}values[idx, j]{{postval}}


@cython.wraparound(False)
@cython.boundscheck(False)
def take_2d_axis1_{{name}}_{{dest}}({{if c_type_in != 'object'}}const{{endif}} {{c_type_in}}[:, :] values,
                                    const int64_t[:] indexer,
                                    {{c_type_out}}[:, :] out,
                                    fill_value=np.nan):
    cdef:
        Py_ssize_t i, j, k, n, idx
        {{c_type_out}} fv

    n = len(values)
    k = len(indexer)

    if n == 0 or k == 0:
        return

    fv = fill_value

    for i from 0 <= i < n:
        for j from 0 <= j < k:
            idx = indexer[j]
            if idx == -1:
                out[i, j] = fv
            else:
                out[i, j] = {{preval}}values[i, idx]{{postval}}


@cython.wraparound(False)
@cython.boundscheck(False)
def take_2d_multi_{{name}}_{{dest}}(ndarray[{{c_type_in}}, ndim=2] values,
                                    indexer,
                                    ndarray[{{c_type_out}}, ndim=2] out,
                                    fill_value=np.nan):
    cdef:
        Py_ssize_t i, j, k, n, idx
        ndarray[int64_t] idx0 = indexer[0]
        ndarray[int64_t] idx1 = indexer[1]
        {{c_type_out}} fv

    n = len(idx0)
    k = len(idx1)

    fv = fill_value
    for i from 0 <= i < n:
        idx = idx0[i]
        if idx == -1:
            for j from 0 <= j < k:
                out[i, j] = fv
        else:
            for j from 0 <= j < k:
                if idx1[j] == -1:
                    out[i, j] = fv
                else:
                    out[i, j] = {{preval}}values[idx, idx1[j]]{{postval}}

{{endfor}}

#----------------------------------------------------------------------
# take_2d internal function
#----------------------------------------------------------------------

{{py:

# dtype, ctype, init_result
dtypes = [('float64', 'float64_t', 'np.empty_like(values)'),
          ('uint64', 'uint64_t', 'np.empty_like(values)'),
          ('object', 'object', 'values.copy()'),
          ('int64', 'int64_t', 'np.empty_like(values)')]
}}

{{for dtype, ctype, init_result in dtypes}}

cdef _take_2d_{{dtype}}(ndarray[{{ctype}}, ndim=2] values, object idx):
    cdef:
        Py_ssize_t i, j, N, K
        ndarray[Py_ssize_t, ndim=2, cast=True] indexer = idx
        ndarray[{{ctype}}, ndim=2] result
        object val

    N, K = (<object> values).shape
    result = {{init_result}}
    for i in range(N):
        for j in range(K):
            result[i, j] = values[i, indexer[i, j]]
    return result

{{endfor}}
