"""
Template for each `dtype` helper function for hashtable

WARNING: DO NOT edit .pxi FILE directly, .pxi is generated from .pxi.in
"""

ctypedef fused table_t:
    kh_float64_t
    kh_uint64_t
    kh_int64_t
    kh_pymap_t


cdef kh_init(table_t **table_ptr):
    if table_t is kh_float64_t:
        table_ptr[0] = kh_init_float64()
    elif table_t is kh_int64_t:
        table_ptr[0] = kh_init_int64()
    elif table_t is kh_uint64_t:
        table_ptr[0] = kh_init_uint64()
    elif table_t is kh_pymap_t:
        table_ptr[0] = kh_init_pymap()
    else:
        raise NotImplementedError


cdef inline void kh_resize(table_t *table, int n) nogil:
    if table_t is kh_float64_t:
        kh_resize_float64(table, n)
    if table_t is kh_uint64_t:
        kh_resize_uint64(table, n)
    if table_t is kh_int64_t:
        kh_resize_int64(table, n)
    if table_t is kh_pymap_t:
        with gil:
            kh_resize_pymap(table, n)


cdef inline kh_destroy(table_t *table):
    if table_t is kh_float64_t:
        kh_destroy_float64(table)
    if table_t is kh_uint64_t:
        kh_destroy_uint64(table)
    if table_t is kh_int64_t:
        kh_destroy_int64(table)
    if table_t is kh_pymap_t:
        kh_destroy_pymap(table)


cdef inline bint kh_exist(table_t *table, int k) nogil:
    if table_t is kh_float64_t:
        return kh_exist_float64(table, k)
    if table_t is kh_uint64_t:
        return kh_exist_uint64(table, k)
    if table_t is kh_int64_t:
        return kh_exist_int64(table, k)
    if table_t is kh_pymap_t:
        with gil:
            return kh_exist_pymap(table, k)


ctypedef fused scalar_t:
    float64_t
    uint64_t
    object
    int64_t


cdef inline khiter_t kh_put(table_t *table, scalar_t val, int* ret) nogil:
    if table_t is kh_float64_t and scalar_t is float64_t:
        return kh_put_float64(table, val, ret)
    if table_t is kh_uint64_t and scalar_t is uint64_t:
        return kh_put_uint64(table, val, ret)
    if table_t is kh_int64_t and scalar_t is int64_t:
        return kh_put_int64(table, val, ret)
    if table_t is kh_pymap_t and scalar_t is object:
        with gil:
            return kh_put_pymap(table, <PyObject*>val, ret)
    # This should never be reached, but let's make it explicit
    raise TypeError


cdef inline khiter_t kh_get(table_t *table, scalar_t val) nogil:
    if table_t is kh_float64_t and scalar_t is float64_t:
        return kh_get_float64(table, val)
    if table_t is kh_uint64_t and scalar_t is uint64_t:
        return kh_get_uint64(table, val)
    if table_t is kh_int64_t and scalar_t is int64_t:
        return kh_get_int64(table, val)
    if table_t is kh_pymap_t and scalar_t is object:
        with gil:
            return kh_get_pymap(table, <PyObject*>val)
    # This should never be reached, but let's make it explicit
    raise TypeError


{{py:

# dtype, ttype, c_type
dtypes = [('float64', 'float64', 'float64_t'),
          ('uint64', 'uint64', 'uint64_t'),
          ('object', 'pymap', 'object'),
          ('int64', 'int64', 'int64_t')]

}}

{{for dtype, ttype, c_type in dtypes}}


@cython.wraparound(False)
@cython.boundscheck(False)
{{if dtype == 'object'}}
cdef build_count_table_{{dtype}}(ndarray[{{dtype}}] values,
                                 kh_{{ttype}}_t *table, bint dropna):
{{else}}
cdef build_count_table_{{dtype}}({{dtype}}_t[:] values,
                                 kh_{{ttype}}_t *table, bint dropna):
{{endif}}
    cdef:
        khiter_t k
        Py_ssize_t i, n = len(values)

        {{c_type}} val

        int ret = 0

    {{if dtype == 'object'}}
    kh_resize(table, n // 10)

    for i in range(n):
        val = values[i]

        if not checknull(val) or not dropna:
            k = kh_get(table, val)
            if k != table.n_buckets:
                table.vals[k] += 1
            else:
                k = kh_put(table, val, &ret)
                table.vals[k] = 1
    {{else}}
    kh_resize(table, n)
    with nogil:

        for i in range(n):
            val = values[i]

            {{if dtype == 'float64'}}
            if val == val or not dropna:
            {{else}}
            if True:
            {{endif}}
                k = kh_get(table, val)
                if k != table.n_buckets:
                    table.vals[k] += 1
                else:
                    k = kh_put(table, val, &ret)
                    table.vals[k] = 1
    {{endif}}


@cython.wraparound(False)
@cython.boundscheck(False)
{{if dtype == 'object'}}
cpdef value_count_{{dtype}}(ndarray[{{dtype}}] values, bint dropna):
{{else}}
cpdef value_count_{{dtype}}({{c_type}}[:] values, bint dropna):
{{endif}}
    cdef:
        Py_ssize_t i = 0
        kh_{{ttype}}_t *table

        {{if dtype != 'object'}}
        {{dtype}}_t[:] result_keys
        int64_t[:] result_counts
        {{endif}}

        Py_ssize_t k

    kh_init(&table)
    {{if dtype == 'object'}}
    build_count_table_{{dtype}}(values, table, 1)
    {{else}}
    build_count_table_{{dtype}}(values, table, dropna)
    {{endif}}

    result_keys = np.empty(table.n_occupied, dtype=np.{{dtype}})
    result_counts = np.zeros(table.n_occupied, dtype=np.int64)

    {{if dtype == 'object'}}
    for k in range(table.n_buckets):
        if kh_exist(table, k):
            result_keys[i] = <{{dtype}}>table.keys[k]
            result_counts[i] = table.vals[k]
            i += 1
    {{else}}
    with nogil:
        for k in range(table.n_buckets):
            if kh_exist(table, k):
                result_keys[i] = table.keys[k]
                result_counts[i] = table.vals[k]
                i += 1
    {{endif}}

    kh_destroy(table)

    {{if dtype == 'object'}}
    return result_keys, result_counts
    {{else}}
    return np.asarray(result_keys), np.asarray(result_counts)
    {{endif}}


@cython.wraparound(False)
@cython.boundscheck(False)
{{if dtype == 'object'}}
def duplicated_{{dtype}}(ndarray[{{dtype}}] values, object keep='first'):
{{else}}
def duplicated_{{dtype}}({{c_type}}[:] values, object keep='first'):
{{endif}}
    cdef:
        int ret = 0
        {{if dtype != 'object'}}
        {{dtype}}_t value
        {{endif}}
        Py_ssize_t k, i, n = len(values)
        kh_{{ttype}}_t *table
        ndarray[uint8_t, ndim=1, cast=True] out = np.empty(n, dtype='bool')

    kh_init(&table)
    kh_resize(table, <int>min(n, _SIZE_HINT_LIMIT))

    if keep not in ('last', 'first', False):
        raise ValueError('keep must be either "first", "last" or False')

    if keep == 'last':
        {{if dtype == 'object'}}
        for i in range(n - 1, -1, -1):
            # equivalent: range(n)[::-1], which cython doesnt like in nogil
            kh_put(table, values[i], &ret)
            out[i] = ret == 0
        {{else}}
        with nogil:
            for i in range(n - 1, -1, -1):
                # equivalent: range(n)[::-1], which cython doesnt like in nogil
                kh_put(table, values[i], &ret)
                out[i] = ret == 0
        {{endif}}
    elif keep == 'first':
        {{if dtype == 'object'}}
        for i in range(n):
            kh_put(table, values[i], &ret)
            out[i] = ret == 0
        {{else}}
        with nogil:
            for i in range(n):
                kh_put(table, values[i], &ret)
                out[i] = ret == 0
        {{endif}}
    else:
        {{if dtype == 'object'}}
        for i in range(n):
            value = values[i]
            k = kh_get(table, value)
            if k != table.n_buckets:
                out[table.vals[k]] = 1
                out[i] = 1
            else:
                k = kh_put(table, value, &ret)
                table.keys[k] = <PyObject*>value
                table.vals[k] = i
                out[i] = 0
        {{else}}
        with nogil:
            for i in range(n):
                value = values[i]
                k = kh_get(table, value)
                if k != table.n_buckets:
                    out[table.vals[k]] = 1
                    out[i] = 1
                else:
                    k = kh_put(table, value, &ret)
                    table.keys[k] = value
                    table.vals[k] = i
                    out[i] = 0
        {{endif}}
    kh_destroy(table)
    return out


# ----------------------------------------------------------------------
# Membership
# ----------------------------------------------------------------------


@cython.wraparound(False)
@cython.boundscheck(False)
{{if dtype == 'object'}}
def ismember_{{dtype}}(ndarray[{{c_type}}] arr, ndarray[{{c_type}}] values):
{{else}}
def ismember_{{dtype}}({{c_type}}[:] arr, {{c_type}}[:] values):
{{endif}}
    """
    Return boolean of values in arr on an
    element by-element basis

    Parameters
    ----------
    arr : {{dtype}} ndarray
    values : {{dtype}} ndarray

    Returns
    -------
    boolean ndarry len of (arr)
    """
    cdef:
        Py_ssize_t i, n, k
        int ret = 0
        ndarray[uint8_t] result
        {{c_type}} val
        kh_{{ttype}}_t *table

    kh_init(&table)

    # construct the table
    n = len(values)
    kh_resize(table, n)

    {{if dtype == 'object'}}
    for i in range(n):
        kh_put(table, values[i], &ret)
    {{else}}
    with nogil:
        for i in range(n):
            kh_put(table, values[i], &ret)
    {{endif}}

    # test membership
    n = len(arr)
    result = np.empty(n, dtype=np.uint8)

    {{if dtype == 'object'}}
    for i in range(n):
        val = arr[i]
        k = kh_get(table, val)
        result[i] = (k != table.n_buckets)
    {{else}}
    with nogil:
        for i in range(n):
            val = arr[i]
            k = kh_get(table, val)
            result[i] = (k != table.n_buckets)
    {{endif}}

    kh_destroy(table)
    return result.view(np.bool_)

{{endfor}}


# ----------------------------------------------------------------------
# Mode Computations
# ----------------------------------------------------------------------

{{py:

# dtype, ctype, table_type, npy_dtype
dtypes = [('float64', 'float64_t', 'float64', 'float64'),
          ('int64', 'int64_t', 'int64', 'int64'),
          ('uint64', 'uint64_t', 'uint64', 'uint64'),
          ('object', 'object', 'pymap', 'object_')]
}}

{{for dtype, ctype, table_type, npy_dtype in dtypes}}


@cython.wraparound(False)
@cython.boundscheck(False)
{{if dtype == 'object'}}
def mode_{{dtype}}(ndarray[{{ctype}}] values, bint dropna):
{{else}}
def mode_{{dtype}}({{ctype}}[:] values, bint dropna):
{{endif}}
    cdef:
        int count, max_count = 1
        int j = -1  # so you can do +=
        Py_ssize_t k
        kh_{{table_type}}_t *table
        ndarray[{{ctype}}] modes

    kh_init(&table)
    build_count_table_{{dtype}}(values, table, dropna)

    modes = np.empty(table.n_buckets, dtype=np.{{npy_dtype}})

    {{if dtype != 'object'}}
    with nogil:
        for k in range(table.n_buckets):
            if kh_exist(table, k):
                count = table.vals[k]
                if count == max_count:
                    j += 1
                elif count > max_count:
                    max_count = count
                    j = 0
                else:
                    continue

                modes[j] = table.keys[k]
    {{else}}
    for k in range(table.n_buckets):
        if kh_exist(table, k):
            count = table.vals[k]

            if count == max_count:
                j += 1
            elif count > max_count:
                max_count = count
                j = 0
            else:
                continue

            modes[j] = <object>table.keys[k]
    {{endif}}

    kh_destroy(table)

    return modes[:j + 1]

{{endfor}}
