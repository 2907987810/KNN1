<?xml version="1.0" encoding="utf-8"?><testsuite errors="82" failures="0" name="pytest" skips="106" tests="804" time="398.622"><testcase classname="pandas.tests.test_algos.TestRank" file="pandas/tests/test_algos.py" line="1510" name="test_pct_max_many_rows[1d]" time="0.00045299530029296875"><skipped message="skipping high memory test since --run-high-memory was not set" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/conftest.py:61: skipping high memory test since --run-high-memory was not set</skipped></testcase><testcase classname="pandas.tests.test_algos.TestRank" file="pandas/tests/test_algos.py" line="1510" name="test_pct_max_many_rows[2d]" time="0.0003230571746826172"><skipped message="skipping high memory test since --run-high-memory was not set" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/conftest.py:61: skipping high memory test since --run-high-memory was not set</skipped></testcase><testcase classname="pandas.tests.frame.test_rank.TestRank" file="pandas/tests/frame/test_rank.py" line="306" name="test_pct_max_many_rows" time="0.00029397010803222656"><skipped message="skipping high memory test since --run-high-memory was not set" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/conftest.py:61: skipping high memory test since --run-high-memory was not set</skipped></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[delims]" time="0.019963741302490234"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[utf8]" time="0.005639076232910156"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[utf16]" time="0.005522966384887695"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[string]" time="0.007016181945800781"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[long]" time="0.007200956344604492"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[nonascii]" time="0.005814552307128906"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[colwidth]" time="0.006597995758056641"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[mixed]" time="0.006367921829223633"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[float]" time="0.0065839290618896484"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="132" name="test_round_trip_frame[int]" time="0.0064411163330078125"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[delims-\t]" time="0.006075859069824219"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[delims-,]" time="0.006036996841430664"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[delims-|]" time="0.00575566291809082"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[utf8-\t]" time="0.00746917724609375"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[utf8-,]" time="0.01335000991821289"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[utf8-|]" time="0.012318134307861328"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[utf16-\t]" time="0.011707067489624023"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[utf16-,]" time="0.009305953979492188"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[utf16-|]" time="0.011989831924438477"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[string-\t]" time="0.013612031936645508"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[string-,]" time="0.0301821231842041"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[string-|]" time="0.07076787948608398"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[long-\t]" time="0.017029285430908203"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[long-,]" time="0.017679214477539062"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[long-|]" time="0.019105911254882812"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[nonascii-\t]" time="0.016354799270629883"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[nonascii-,]" time="0.014273405075073242"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[nonascii-|]" time="0.012491464614868164"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[colwidth-\t]" time="0.014076709747314453"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[colwidth-,]" time="0.012329816818237305"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[colwidth-|]" time="0.011272430419921875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[mixed-\t]" time="0.012700080871582031"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[mixed-,]" time="0.013052940368652344"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[mixed-|]" time="0.01136016845703125"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[float-\t]" time="0.01160573959350586"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[float-,]" time="0.012765884399414062"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[float-|]" time="0.012037038803100586"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[int-\t]" time="0.012915849685668945"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[int-,]" time="0.016521215438842773"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="136" name="test_round_trip_frame_sep[int-|]" time="0.01227712631225586"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[delims]" time="0.41144895553588867"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[utf8]" time="0.007967948913574219"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[utf16]" time="0.00956106185913086"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[string]" time="0.010782003402709961"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[long]" time="0.012978076934814453"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[nonascii]" time="0.008833885192871094"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[colwidth]" time="0.009853601455688477"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[mixed]" time="0.009069442749023438"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[float]" time="0.009630918502807617"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="141" name="test_round_trip_frame_string[int]" time="0.009190082550048828"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[delims]" time="0.004075765609741211"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[utf8]" time="0.004107952117919922"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[utf16]" time="0.004128694534301758"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[string]" time="0.0048449039459228516"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[long]" time="0.006058931350708008"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[nonascii]" time="0.004140377044677734"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[colwidth]" time="0.004923105239868164"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[mixed]" time="0.004987001419067383"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[float]" time="0.004920244216918945"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="149" name="test_excel_sep_warning[int]" time="0.006128072738647461"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[delims]" time="0.004652976989746094"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[utf8]" time="0.003901958465576172"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[utf16]" time="0.0037870407104492188"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[string]" time="0.004796028137207031"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[long]" time="0.005903720855712891"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[nonascii]" time="0.0036962032318115234"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[colwidth]" time="0.004760265350341797"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[mixed]" time="0.0044634342193603516"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[float]" time="0.004528045654296875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="154" name="test_copy_delim_warning[int]" time="0.004458427429199219"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-True-\t]" time="0.003281831741333008"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-True-None]" time="0.003556966781616211"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-True-default]" time="0.003368854522705078"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-None-\t]" time="0.003135204315185547"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-None-None]" time="0.0031540393829345703"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-None-default]" time="0.0033349990844726562"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-default-\t]" time="0.0033674240112304688"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-default-None]" time="0.0033261775970458984"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[delims-default-default]" time="0.003477811813354492"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-True-\t]" time="0.0032820701599121094"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-True-None]" time="0.003612041473388672"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-True-default]" time="0.0034279823303222656"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-None-\t]" time="0.004452943801879883"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-None-None]" time="0.0033354759216308594"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-None-default]" time="0.003667116165161133"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-default-\t]" time="0.0033659934997558594"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-default-None]" time="0.0033359527587890625"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf8-default-default]" time="0.0035698413848876953"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-True-\t]" time="0.008450984954833984"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-True-None]" time="0.016758441925048828"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-True-default]" time="0.012073040008544922"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-None-\t]" time="0.007100820541381836"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-None-None]" time="0.006899833679199219"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-None-default]" time="0.006049633026123047"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-default-\t]" time="0.005402803421020508"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-default-None]" time="0.006504535675048828"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[utf16-default-default]" time="0.006241321563720703"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-True-\t]" time="0.006248950958251953"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-True-None]" time="0.0053598880767822266"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-True-default]" time="0.007727622985839844"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-None-\t]" time="0.0058820247650146484"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-None-None]" time="0.0068967342376708984"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-None-default]" time="0.007803201675415039"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-default-\t]" time="0.008467435836791992"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-default-None]" time="0.0077056884765625"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[string-default-default]" time="0.008387565612792969"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-True-\t]" time="0.027560949325561523"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-True-None]" time="0.02353072166442871"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-True-default]" time="0.024567127227783203"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-None-\t]" time="0.010908126831054688"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-None-None]" time="0.009138107299804688"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-None-default]" time="0.008453130722045898"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-default-\t]" time="0.008331298828125"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-default-None]" time="0.008132696151733398"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[long-default-default]" time="0.008376836776733398"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-True-\t]" time="0.006351947784423828"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-True-None]" time="0.0071680545806884766"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-True-default]" time="0.006441831588745117"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-None-\t]" time="0.0052433013916015625"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-None-None]" time="0.006426334381103516"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-None-default]" time="0.005895137786865234"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-default-\t]" time="0.005140781402587891"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-default-None]" time="0.005524158477783203"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[nonascii-default-default]" time="0.006847381591796875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-True-\t]" time="0.0073740482330322266"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-True-None]" time="0.007449150085449219"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-True-default]" time="0.0072803497314453125"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-None-\t]" time="0.0073719024658203125"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-None-None]" time="0.006873369216918945"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-None-default]" time="0.008033037185668945"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-default-\t]" time="0.006973981857299805"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-default-None]" time="0.0051805973052978516"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[colwidth-default-default]" time="0.005890607833862305"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-True-\t]" time="0.006392002105712891"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-True-None]" time="0.006670713424682617"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-True-default]" time="0.007027149200439453"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-None-\t]" time="0.005541801452636719"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-None-None]" time="0.006784200668334961"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-None-default]" time="0.007358074188232422"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-default-\t]" time="0.007575273513793945"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-default-None]" time="0.0061953067779541016"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[mixed-default-default]" time="0.006494760513305664"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-True-\t]" time="0.0065500736236572266"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-True-None]" time="0.006571292877197266"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-True-default]" time="0.007518768310546875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-None-\t]" time="0.0063669681549072266"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-None-None]" time="0.0040569305419921875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-None-default]" time="0.004601240158081055"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-default-\t]" time="0.0037682056427001953"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-default-None]" time="0.0033359527587890625"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[float-default-default]" time="0.0034029483795166016"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-True-\t]" time="0.003698110580444336"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-True-None]" time="0.003473997116088867"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-True-default]" time="0.0035009384155273438"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-None-\t]" time="0.003988027572631836"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-None-None]" time="0.0035059452056884766"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-None-default]" time="0.003511190414428711"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-default-\t]" time="0.0038390159606933594"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-default-None]" time="0.003593921661376953"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="160" name="test_clipboard_copy_tabs_default[int-default-default]" time="0.003643035888671875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[delims-False-None]" time="0.008112192153930664"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[delims-False-default]" time="0.009540796279907227"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[utf8-False-None]" time="0.008059024810791016"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[utf8-False-default]" time="0.007656097412109375"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[utf16-False-None]" time="0.007821798324584961"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[utf16-False-default]" time="0.007702350616455078"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[string-False-None]" time="0.00953531265258789"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[string-False-default]" time="0.009652853012084961"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[long-False-None]" time="0.012439966201782227"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[long-False-default]" time="0.01289510726928711"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[nonascii-False-None]" time="0.007959127426147461"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[nonascii-False-default]" time="0.007833480834960938"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[colwidth-False-None]" time="0.009519100189208984"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[colwidth-False-default]" time="0.010096073150634766"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[mixed-False-None]" time="0.009812355041503906"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[mixed-False-default]" time="0.011778116226196289"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[float-False-None]" time="0.011182785034179688"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[float-False-default]" time="0.01058506965637207"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[int-False-None]" time="0.008586645126342773"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="169" name="test_clipboard_copy_strings[int-False-default]" time="0.008962869644165039"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="178" name="test_read_clipboard_infer_excel" time="0.010291099548339844"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[delims]" time="0.0025310516357421875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[utf8]" time="0.0022950172424316406"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[utf16]" time="0.008501052856445312"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[string]" time="0.0038399696350097656"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[long]" time="0.004445552825927734"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[nonascii]" time="0.0028901100158691406"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[colwidth]" time="0.004142045974731445"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[mixed]" time="0.003551959991455078"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[float]" time="0.004558563232421875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="213" name="test_invalid_encoding[int]" time="0.002901315689086914"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[delims-UTF-8]" time="0.009303092956542969"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[delims-utf-8]" time="0.007519960403442383"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[delims-utf8]" time="0.009190559387207031"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[utf8-UTF-8]" time="0.0074961185455322266"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[utf8-utf-8]" time="0.010143041610717773"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[utf8-utf8]" time="0.007160186767578125"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[utf16-UTF-8]" time="0.014332294464111328"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[utf16-utf-8]" time="0.022181272506713867"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[utf16-utf8]" time="0.02858877182006836"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[string-UTF-8]" time="0.06203103065490723"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[string-utf-8]" time="0.037899017333984375"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[string-utf8]" time="0.04546403884887695"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[long-UTF-8]" time="0.042418718338012695"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[long-utf-8]" time="0.028917789459228516"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[long-utf8]" time="0.03075385093688965"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[nonascii-UTF-8]" time="0.028270959854125977"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[nonascii-utf-8]" time="0.031475067138671875"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[nonascii-utf8]" time="0.019299030303955078"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[colwidth-UTF-8]" time="0.018611907958984375"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[colwidth-utf-8]" time="0.024274110794067383"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[colwidth-utf8]" time="0.024849891662597656"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[mixed-UTF-8]" time="0.018874168395996094"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[mixed-utf-8]" time="0.017717599868774414"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[mixed-utf8]" time="0.022989749908447266"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[float-UTF-8]" time="0.015404701232910156"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[float-utf-8]" time="0.01948404312133789"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[float-utf8]" time="0.014077186584472656"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[int-UTF-8]" time="0.01643538475036621"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[int-utf-8]" time="0.0160219669342041"></testcase><testcase classname="pandas.tests.io.test_clipboard.TestClipboard" file="pandas/tests/io/test_clipboard.py" line="220" name="test_round_trip_valid_encodings[int-utf8]" time="0.018283843994140625"></testcase><testcase classname="pandas.tests.io.test_clipboard" file="pandas/tests/io/test_clipboard.py" line="225" name="test_raw_roundtrip[\U0001f44d...]" time="0.12206721305847168"></testcase><testcase classname="pandas.tests.io.test_clipboard" file="pandas/tests/io/test_clipboard.py" line="225" name="test_raw_roundtrip[\u03a9\u0153\u2211\xb4...]" time="0.06836986541748047"></testcase><testcase classname="pandas.tests.io.test_clipboard" file="pandas/tests/io/test_clipboard.py" line="225" name="test_raw_roundtrip[abcd...]" time="0.07223796844482422"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="40" name="test_error" time="0.008886337280273438"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="46" name="test_basic" time="0.09064221382141113"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="67" name="test_duplicate_columns" time="0.8813486099243164"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="75" name="test_stringify_columns" time="0.004717826843261719"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="80" name="test_read_columns" time="0.017945051193237305"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="90" name="test_unsupported_other" time="0.14609813690185547"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="97" name="test_rw_nthreads" time="0.023752927780151367"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="117" name="test_rw_use_threads" time="0.01852893829345703"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="122" name="test_write_with_index" time="0.013406038284301758"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="149" name="test_path_pathlib" time="0.01274418830871582"></testcase><testcase classname="pandas.tests.io.test_feather.TestFeather" file="pandas/tests/io/test_feather.py" line="154" name="test_path_localpath" time="0.012340784072875977"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="155" name="test_format_kwarg_in_constructor" time="0.0014901161193847656"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="161" name="test_context" time="0.06573319435119629"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="181" name="test_conv_read_write" time="0.2530639171600342"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="206" name="test_long_strings" time="0.06522130966186523"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="218" name="test_api" time="0.504035472869873"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="309" name="test_api_default_format" time="0.1740880012512207"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="353" name="test_keys" time="0.03939700126647949"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="365" name="test_keys_ignore_hdf_softlink" time="0.023967981338500977"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="382" name="test_iter_empty" time="0.0063419342041015625"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="388" name="test_repr" time="0.23824691772460938"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="433" name="test_contains" time="0.21229028701782227"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="453" name="test_versioning" time="0.2934906482696533"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="476" name="test_mode" time="0.25626420974731445"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="537" name="test_reopen_handle" time="0.03157997131347656"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="585" name="test_open_args" time="0.04157876968383789"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="605" name="test_flush" time="0.008338451385498047"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="612" name="test_get" time="0.011462926864624023"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="627" name="test_walk[/-expected0]" time="0.0959329605102539"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="627" name="test_walk[/second_group-expected1]" time="0.1404116153717041"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="678" name="test_getattr" time="0.06425213813781738"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="705" name="test_put" time="0.2545950412750244"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="736" name="test_put_string_index" time="0.26967406272888184"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="763" name="test_put_compression" time="0.13811206817626953"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="775" name="test_put_compression_blosc" time="0.1462268829345703"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="788" name="test_complibs_default_settings" time="0.4176473617553711"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="841" name="test_complibs" time="2.997718095779419"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="878" name="test_put_integer" time="0.059255123138427734"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="883" name="test_put_mixed_type" time="0.05618906021118164"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="911" name="test_append" time="0.46898722648620605"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="974" name="test_append_series" time="0.14951705932617188"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1020" name="test_store_index_types" time="0.2010488510131836"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1050" name="test_encoding" time="0.028132200241088867"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1066" name="test_latin_encoding" time="1.576535940170288"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1111" name="test_append_some_nans" time="0.13787603378295898"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1152" name="test_append_all_nans" time="0.46395349502563477"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1235" name="test_read_missing_key_close_store" time="0.03464961051940918"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1248" name="test_append_frame_column_oriented" time="0.0943596363067627"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1274" name="test_append_with_different_block_ordering" time="0.21877264976501465"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1318" name="test_append_with_strings" time="0.3621642589569092"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1433" name="test_append_with_empty_string" time="0.032767295837402344"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1443" name="test_to_hdf_with_min_itemsize" time="0.14322590827941895"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1463" name="test_to_hdf_errors[fixed]" time="0.02481365203857422"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1463" name="test_to_hdf_errors[table]" time="0.03793907165527344"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1478" name="test_append_with_data_columns" time="0.7647314071655273"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1629" name="test_create_table_index" time="0.07815742492675781"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1660" name="test_append_hierarchical" time="0.1356799602508545"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1685" name="test_column_multiindex" time="0.11908984184265137"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1735" name="test_store_multiindex" time="0.3442869186401367"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1792" name="test_select_columns_in_where" time="0.10918283462524414"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1823" name="test_mi_data_columns" time="0.2008838653564453"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1836" name="test_pass_spec_to_storer" time="0.04753923416137695"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1847" name="test_append_misc" time="0.2745375633239746"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1898" name="test_append_raise" time="0.10895824432373047"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1943" name="test_table_index_incompatible_dtypes" time="0.037545204162597656"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1953" name="test_table_values_dtypes_roundtrip" time="0.3588860034942627"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="1996" name="test_table_mixed_dtypes" time="0.0575709342956543"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2018" name="test_unimplemented_dtypes_table_columns" time="0.035727739334106445"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2043" name="test_calendar_roundtrip_issue" time="0.10385298728942871"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2073" name="test_roundtrip_tz_aware_index" time="0.01909923553466797"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2084" name="test_append_with_timedelta" time="0.3570990562438965"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2126" name="test_remove" time="0.12027931213378906"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2164" name="test_invalid_terms" time="0.18321776390075684"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2207" name="test_same_name_scoping" time="0.07268500328063965"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2230" name="test_series" time="0.06984186172485352"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2246" name="test_sparse_series" time="0.09731268882751465"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2262" name="test_sparse_frame" time="0.29600071907043457"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2280" name="test_float_index" time="0.008630037307739258"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2287" name="test_tuple_index" time="0.01919841766357422"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2300" name="test_index_types" time="0.09867167472839355"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2355" name="test_timeseries_preepoch" time="0.2748270034790039"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2364" name="test_frame[False]" time="0.12226057052612305"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2364" name="test_frame[True]" time="0.0903470516204834"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2395" name="test_empty_series_frame" time="0.07271265983581543"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2409" name="test_empty_series[int64]" time="0.013523101806640625"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2409" name="test_empty_series[float64]" time="0.016955852508544922"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2409" name="test_empty_series[object]" time="0.018213748931884766"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2409" name="test_empty_series[m8[ns]]" time="0.015980243682861328"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2409" name="test_empty_series[M8[ns]]" time="0.017715930938720703"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2416" name="test_can_serialize_dates" time="0.025499582290649414"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2423" name="test_store_hierarchical" time="0.11601924896240234"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2442" name="test_store_index_name" time="0.017008304595947266"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2451" name="test_store_index_name_with_tz" time="0.019829273223876953"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2463" name="test_store_index_name_numpy_str[table]" time="0.02740311622619629"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2463" name="test_store_index_name_numpy_str[fixed]" time="0.017297744750976562"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2484" name="test_store_series_name" time="0.008833646774291992"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2493" name="test_store_mixed[False]" time="0.14760184288024902"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2493" name="test_store_mixed[True]" time="0.13107013702392578"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2529" name="test_select_with_dups" time="0.1570589542388916"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2591" name="test_overwrite_node" time="0.04432034492492676"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2600" name="test_sparse_with_compression" time="1.0766651630401611"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2632" name="test_select" time="0.2345294952392578"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2672" name="test_select_dtypes" time="0.7230696678161621"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2781" name="test_select_with_many_inputs" time="0.19000625610351562"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2828" name="test_select_iterator" time="0.9064273834228516"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2896" name="test_select_iterator_complete_8014" time="3.4734699726104736"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="2970" name="test_select_iterator_non_complete_8014" time="2.0980803966522217"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3026" name="test_select_iterator_many_empty_frames" time="0.9757940769195557"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3087" name="test_retain_index_attributes" time="0.03740406036376953"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3132" name="test_retain_index_attributes2" time="0.07754087448120117"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3167" name="test_frame_select" time="0.05830502510070801"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3200" name="test_frame_select_complex" time="0.16232585906982422"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3251" name="test_frame_select_complex2" time="0.5783555507659912"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3315" name="test_invalid_filtering" time="0.07775425910949707"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3332" name="test_string_select" time="0.26062893867492676"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3379" name="test_read_column" time="0.14031410217285156"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3451" name="test_coordinates" time="0.3852066993713379"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3554" name="test_append_to_multiple" time="0.14936113357543945"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3582" name="test_append_to_multiple_dropna" time="0.17875981330871582"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3600" name="test_append_to_multiple_dropna_false" time="0.0004916191101074219"><skipped message="expected test failure">reason: [NOTRUN] append_to_multiple_dropna_false is not raising as failed</skipped></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3622" name="test_select_as_multiple" time="0.1444854736328125"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3688" name="test_nan_selection_bug_4858" time="0.025419235229492188"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3709" name="test_start_stop_table" time="0.02692890167236328"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3729" name="test_start_stop_multiple" time="0.041458845138549805"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3744" name="test_start_stop_fixed" time="0.05340909957885742"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3790" name="test_select_filter_corner" time="0.08298158645629883"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3807" name="test_path_pathlib" time="0.04108285903930664"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3815" name="test_contiguous_mixed_data_table[0-2]" time="0.03473687171936035"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3815" name="test_contiguous_mixed_data_table[1-2]" time="0.03981757164001465"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3815" name="test_contiguous_mixed_data_table[None-None]" time="0.07038307189941406"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3828" name="test_path_pathlib_hdfstore" time="0.06339287757873535"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3842" name="test_pickle_path_localpath" time="0.061690330505371094"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3849" name="test_path_localpath_hdfstore" time="0.055327653884887695"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="3899" name="test_multiple_open_close" time="0.23899507522583008"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4022" name="test_pytables_native_read" time="0.03314065933227539"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4029" name="test_pytables_native2_read" time="0.034477949142456055"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4039" name="test_legacy_table_fixed_format_read_py2" time="0.04767179489135742"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4054" name="test_legacy_table_read_py2" time="0.03755021095275879"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4069" name="test_copy" time="0.15053629875183105"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4126" name="test_store_datetime_fractional_secs" time="0.008610963821411133"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4134" name="test_tseries_indices_series" time="0.014770030975341797"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4155" name="test_tseries_indices_frame" time="0.030251026153564453"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4178" name="test_unicode_index" time="0.012912750244140625"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4188" name="test_unicode_longer_encoded" time="0.08677291870117188"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4203" name="test_store_datetime_mixed" time="0.0832512378692627"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4221" name="test_append_with_diff_col_name_types_raises_value_error" time="0.05552816390991211"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4236" name="test_query_with_nested_special_character" time="0.047289133071899414"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4246" name="test_categorical" time="1.3980169296264648"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4349" name="test_categorical_conversion" time="0.5626027584075928"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4379" name="test_categorical_nan_only_columns" time="0.19505548477172852"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4398" name="test_duplicate_column_name" time="0.03900480270385742"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4412" name="test_round_trip_equals" time="0.030974864959716797"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4423" name="test_preserve_timedeltaindex_type" time="0.017264842987060547"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4436" name="test_columns_multiindex_modified" time="0.03934526443481445"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4459" name="test_to_hdf_with_object_column_names" time="0.17905330657958984"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4489" name="test_read_hdf_open_store" time="0.04150271415710449"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4507" name="test_read_hdf_iterator" time="0.19820404052734375"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4523" name="test_read_hdf_errors" time="0.0171048641204834"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4539" name="test_read_hdf_generic_buffer_errors" time="0.0030906200408935547"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4543" name="test_invalid_complib" time="0.002672433853149414"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4552" name="test_read_nokey" time="0.08820199966430664"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4568" name="test_read_nokey_table" time="0.30675315856933594"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4582" name="test_read_nokey_empty" time="0.007918834686279297"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4590" name="test_read_from_pathlib_path" time="0.04285597801208496"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4607" name="test_read_from_py_localpath" time="0.04635190963745117"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4624" name="test_query_long_float_literal" time="0.08848428726196289"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4647" name="test_query_compare_column_type" time="0.2190556526184082"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4691" name="test_read_hdf_series_mode_r[fixed]" time="0.012856006622314453"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4691" name="test_read_hdf_series_mode_r[table]" time="0.03896689414978027"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4702" name="test_fspath" time="0.0033845901489257812"></testcase><testcase classname="pandas.tests.io.test_pytables.TestHDFStore" file="pandas/tests/io/test_pytables.py" line="4708" name="test_read_py2_hdf_file_in_py3" time="0.013620138168334961"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="546" name="test_read_sql_iris[load_iris_data0]" time="0.12649917602539062"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="551" name="test_read_sql_view[load_iris_data0]" time="0.09441995620727539"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="556" name="test_to_sql[load_iris_data0]" time="0.0626821517944336"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="560" name="test_to_sql_fail[load_iris_data0]" time="0.09262394905090332"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="570" name="test_to_sql_replace[load_iris_data0]" time="0.11783194541931152"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="583" name="test_to_sql_append[load_iris_data0]" time="0.04971742630004883"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="597" name="test_to_sql_type_mapping[load_iris_data0]" time="0.04033184051513672"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="603" name="test_to_sql_series[load_iris_data0]" time="0.046530961990356445"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="609" name="test_roundtrip[load_iris_data0]" time="0.05879068374633789"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="623" name="test_roundtrip_chunksize[load_iris_data0]" time="0.21422386169433594"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="631" name="test_execute_sql[load_iris_data0]" time="0.0872189998626709"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="637" name="test_date_parsing[load_iris_data0]" time="0.12005972862243652"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="683" name="test_date_and_index[load_iris_data0]" time="0.13126659393310547"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="693" name="test_timedelta[load_iris_data0]" time="0.09663915634155273"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="703" name="test_complex_raises[load_iris_data0]" time="0.03549695014953613"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-None-index]" time="0.04507803916931152"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-other_label-other_label]" time="0.04252290725708008"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-index_name-None-index_name]" time="0.082855224609375"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-index_name-other_label-other_label]" time="0.13660788536071777"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-0-None-0]" time="0.0615992546081543"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-0-0]" time="0.04604005813598633"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="733" name="test_to_sql_index_label_multiindex[load_iris_data0]" time="0.07958316802978516"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="769" name="test_multiindex_roundtrip[load_iris_data0]" time="0.05456900596618652"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="778" name="test_integer_col_names[load_iris_data0]" time="0.0431058406829834"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="783" name="test_get_schema[load_iris_data0]" time="0.09444499015808105"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="787" name="test_get_schema_dtypes[load_iris_data0]" time="0.06261444091796875"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="795" name="test_get_schema_keys[load_iris_data0]" time="0.07212710380554199"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="807" name="test_chunksize_read[load_iris_data0]" time="0.19601202011108398"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="841" name="test_categorical[load_iris_data0]" time="0.09750890731811523"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="855" name="test_unicode_column_name[load_iris_data0]" time="0.05676102638244629"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="860" name="test_escaped_table_name[load_iris_data0]" time="0.04088473320007324"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="888" name="test_read_table_columns[load_iris_data0]" time="0.04594874382019043"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="896" name="test_read_table_index_col[load_iris_data0]" time="0.12532615661621094"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="913" name="test_read_sql_delegate[load_iris_data0]" time="0.06022167205810547"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="924" name="test_not_reflect_all_tables[load_iris_data0]" time="0.04141068458557129"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="940" name="test_warning_case_insensitive_table_name[load_iris_data0]" time="0.037149906158447266"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="961" name="test_sqlalchemy_type_mapping[load_iris_data0]" time="0.034604549407958984"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="971" name="test_database_uri_string[load_iris_data0]" time="0.12120175361633301"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="1016" name="test_query_by_text_obj[load_iris_data0]" time="0.029220104217529297"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApi" file="pandas/tests/io/test_sql.py" line="1024" name="test_query_by_select_obj[load_iris_data0]" time="0.03171896934509277"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="546" name="test_read_sql_iris[load_iris_data0]" time="0.03094196319580078"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="551" name="test_read_sql_view[load_iris_data0]" time="0.07678794860839844"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="556" name="test_to_sql[load_iris_data0]" time="0.12062811851501465"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="560" name="test_to_sql_fail[load_iris_data0]" time="0.1475849151611328"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="570" name="test_to_sql_replace[load_iris_data0]" time="0.08372092247009277"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="583" name="test_to_sql_append[load_iris_data0]" time="0.08030962944030762"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="597" name="test_to_sql_type_mapping[load_iris_data0]" time="0.07190465927124023"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="603" name="test_to_sql_series[load_iris_data0]" time="0.08774971961975098"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="609" name="test_roundtrip[load_iris_data0]" time="0.07522702217102051"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="623" name="test_roundtrip_chunksize[load_iris_data0]" time="0.03835892677307129"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="631" name="test_execute_sql[load_iris_data0]" time="0.028111934661865234"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="637" name="test_date_parsing[load_iris_data0]" time="0.04471325874328613"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="683" name="test_date_and_index[load_iris_data0]" time="0.03298330307006836"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="693" name="test_timedelta[load_iris_data0]" time="0.038582801818847656"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="703" name="test_complex_raises[load_iris_data0]" time="0.028885841369628906"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-None-index]" time="0.036864280700683594"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-other_label-other_label]" time="0.03635525703430176"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-index_name-None-index_name]" time="0.03710126876831055"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-index_name-other_label-other_label]" time="0.0363001823425293"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-0-None-0]" time="0.039710044860839844"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-0-0]" time="0.03813505172729492"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="733" name="test_to_sql_index_label_multiindex[load_iris_data0]" time="0.13087916374206543"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="769" name="test_multiindex_roundtrip[load_iris_data0]" time="0.1141672134399414"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="778" name="test_integer_col_names[load_iris_data0]" time="0.07290291786193848"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="783" name="test_get_schema[load_iris_data0]" time="0.030910968780517578"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="787" name="test_get_schema_dtypes[load_iris_data0]" time="0.030223846435546875"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="795" name="test_get_schema_keys[load_iris_data0]" time="0.03689002990722656"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="807" name="test_chunksize_read[load_iris_data0]" time="0.09500718116760254"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="841" name="test_categorical[load_iris_data0]" time="0.09088993072509766"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="855" name="test_unicode_column_name[load_iris_data0]" time="0.1371152400970459"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="860" name="test_escaped_table_name[load_iris_data0]" time="0.07286429405212402"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="888" name="test_read_table_columns[load_iris_data0]" time="0.04224705696105957"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="896" name="test_read_table_index_col[load_iris_data0]" time="0.05934619903564453"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="913" name="test_read_sql_delegate[load_iris_data0]" time="0.05030369758605957"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="924" name="test_not_reflect_all_tables[load_iris_data0]" time="0.0422971248626709"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="940" name="test_warning_case_insensitive_table_name[load_iris_data0]" time="0.041594743728637695"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="961" name="test_sqlalchemy_type_mapping[load_iris_data0]" time="0.030737638473510742"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="971" name="test_database_uri_string[load_iris_data0]" time="0.06807065010070801"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="1016" name="test_query_by_text_obj[load_iris_data0]" time="0.03563284873962402"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLApiConn" file="pandas/tests/io/test_sql.py" line="1024" name="test_query_by_select_obj[load_iris_data0]" time="0.04807400703430176"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="546" name="test_read_sql_iris[load_iris_data0]" time="0.014934539794921875"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="551" name="test_read_sql_view[load_iris_data0]" time="0.018772125244140625"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="556" name="test_to_sql[load_iris_data0]" time="0.017885923385620117"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="560" name="test_to_sql_fail[load_iris_data0]" time="0.021825551986694336"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="570" name="test_to_sql_replace[load_iris_data0]" time="0.025999069213867188"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="583" name="test_to_sql_append[load_iris_data0]" time="0.05254507064819336"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="597" name="test_to_sql_type_mapping[load_iris_data0]" time="0.04165291786193848"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="603" name="test_to_sql_series[load_iris_data0]" time="0.016779661178588867"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="609" name="test_roundtrip[load_iris_data0]" time="0.014411687850952148"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="623" name="test_roundtrip_chunksize[load_iris_data0]" time="0.012055635452270508"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="631" name="test_execute_sql[load_iris_data0]" time="0.007033348083496094"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="637" name="test_date_parsing[load_iris_data0]" time="0.022957801818847656"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="683" name="test_date_and_index[load_iris_data0]" time="0.011061906814575195"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="693" name="test_timedelta[load_iris_data0]" time="0.01090693473815918"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="703" name="test_complex_raises[load_iris_data0]" time="0.007931709289550781"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-None-index]" time="0.01137995719909668"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-other_label-other_label]" time="0.010232925415039062"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-index_name-None-index_name]" time="0.010387182235717773"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-index_name-other_label-other_label]" time="0.015998125076293945"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-0-None-0]" time="0.01970672607421875"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="709" name="test_to_sql_index_label[load_iris_data0-None-0-0]" time="0.015954256057739258"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="733" name="test_to_sql_index_label_multiindex[load_iris_data0]" time="0.0445866584777832"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="769" name="test_multiindex_roundtrip[load_iris_data0]" time="0.036834001541137695"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="778" name="test_integer_col_names[load_iris_data0]" time="0.03966856002807617"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="783" name="test_get_schema[load_iris_data0]" time="0.02831888198852539"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="787" name="test_get_schema_dtypes[load_iris_data0]" time="0.03943371772766113"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="795" name="test_get_schema_keys[load_iris_data0]" time="0.0334012508392334"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="807" name="test_chunksize_read[load_iris_data0]" time="0.06780362129211426"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="841" name="test_categorical[load_iris_data0]" time="0.03996133804321289"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="855" name="test_unicode_column_name[load_iris_data0]" time="0.06091618537902832"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="860" name="test_escaped_table_name[load_iris_data0]" time="0.07887101173400879"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="1078" name="test_sql_open_close[load_iris_data0]" time="0.04907989501953125"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="1096" name="test_con_string_import_error[load_iris_data0]" time="0.0018663406372070312"><skipped message="SQLAlchemy is installed" type="pytest.skip">pandas/tests/io/test_sql.py:1096: SQLAlchemy is installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="1103" name="test_read_sql_delegate[load_iris_data0]" time="0.01784658432006836"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="1112" name="test_safe_names_warning[load_iris_data0]" time="0.011310577392578125"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="1119" name="test_get_schema2[load_iris_data0]" time="0.010066747665405273"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallbackApi" file="pandas/tests/io/test_sql.py" line="1131" name="test_sqlite_type_mapping[load_iris_data0]" time="0.017029762268066406"></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1195" name="test_read_sql[load_iris_data0]" time="0.137437105178833"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1198" name="test_read_sql_parameter[load_iris_data0]" time="0.0007979869842529297"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1201" name="test_read_sql_named_parameter[load_iris_data0]" time="0.0006568431854248047"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1204" name="test_to_sql[load_iris_data0]" time="0.0010519027709960938"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1207" name="test_to_sql_empty[load_iris_data0]" time="0.0009493827819824219"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1210" name="test_to_sql_fail[load_iris_data0]" time="0.0008647441864013672"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1213" name="test_to_sql_replace[load_iris_data0]" time="0.0008783340454101562"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1216" name="test_to_sql_append[load_iris_data0]" time="0.0005731582641601562"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1219" name="test_to_sql_method_multi[load_iris_data0]" time="0.0018391609191894531"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1222" name="test_to_sql_method_callable[load_iris_data0]" time="0.0008900165557861328"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1225" name="test_create_table[load_iris_data0]" time="0.0009999275207519531"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1235" name="test_drop_table[load_iris_data0]" time="0.0026619434356689453"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1250" name="test_roundtrip[load_iris_data0]" time="0.0006344318389892578"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1253" name="test_execute_sql[load_iris_data0]" time="0.001798391342163086"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1256" name="test_read_table[load_iris_data0]" time="0.0010020732879638672"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1260" name="test_read_table_columns[load_iris_data0]" time="0.0007200241088867188"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1266" name="test_read_table_absent_raises[load_iris_data0]" time="0.000705718994140625"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1283" name="test_bigint[load_iris_data0]" time="0.0009963512420654297"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1291" name="test_default_date_load[load_iris_data0]" time="0.0006182193756103516"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1298" name="test_datetime_with_timezone[load_iris_data0]" time="0.0007708072662353516"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1369" name="test_datetime_with_timezone_roundtrip[load_iris_data0]" time="0.0010559558868408203"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1398" name="test_naive_datetimeindex_roundtrip[load_iris_data0]" time="0.0014829635620117188"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1409" name="test_date_parsing[load_iris_data0]" time="0.0005311965942382812"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1439" name="test_datetime[load_iris_data0]" time="0.0008080005645751953"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1459" name="test_datetime_NaT[load_iris_data0]" time="0.001497030258178711"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1478" name="test_datetime_date[load_iris_data0]" time="0.0034151077270507812"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1488" name="test_datetime_time[load_iris_data0]" time="0.0007197856903076172"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1511" name="test_mixed_dtype_insert[load_iris_data0]" time="0.005142927169799805"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1523" name="test_nan_numeric[load_iris_data0]" time="0.001094818115234375"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1536" name="test_nan_fullcolumn[load_iris_data0]" time="0.0006949901580810547"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1551" name="test_nan_string[load_iris_data0]" time="0.0010118484497070312"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1574" name="test_to_sql_save_index[load_iris_data0]" time="0.0005388259887695312"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1577" name="test_transactions[load_iris_data0]" time="0.0005478858947753906"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1580" name="test_get_schema_create_table[load_iris_data0]" time="0.0009038448333740234"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1597" name="test_dtype[load_iris_data0]" time="0.0009090900421142578"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1628" name="test_notna_dtype[load_iris_data0]" time="0.0007202625274658203"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1653" name="test_double_precision[load_iris_data0]" time="0.001171112060546875"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1681" name="test_connectable_issue_example[load_iris_data0]" time="0.0005633831024169922"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1703" name="test_temporary_table[load_iris_data0]" time="0.0005428791046142578"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1804" name="test_default_type_conversion[load_iris_data0]" time="0.000759124755859375"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemy" file="pandas/tests/io/test_sql.py" line="1819" name="test_read_procedure[load_iris_data0]" time="0.0035822391510009766"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemy object at 0x1408ef978&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x146406978&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1195" name="test_read_sql[load_iris_data0]" time="0.0029859542846679688"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1198" name="test_read_sql_parameter[load_iris_data0]" time="0.0006203651428222656"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1201" name="test_read_sql_named_parameter[load_iris_data0]" time="0.0007441043853759766"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1204" name="test_to_sql[load_iris_data0]" time="0.0007178783416748047"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1207" name="test_to_sql_empty[load_iris_data0]" time="0.0011327266693115234"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1210" name="test_to_sql_fail[load_iris_data0]" time="0.0014200210571289062"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1213" name="test_to_sql_replace[load_iris_data0]" time="0.0005478858947753906"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1216" name="test_to_sql_append[load_iris_data0]" time="0.0007152557373046875"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1219" name="test_to_sql_method_multi[load_iris_data0]" time="0.0010709762573242188"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1222" name="test_to_sql_method_callable[load_iris_data0]" time="0.0006918907165527344"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1225" name="test_create_table[load_iris_data0]" time="0.0012581348419189453"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1235" name="test_drop_table[load_iris_data0]" time="0.0009918212890625"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1250" name="test_roundtrip[load_iris_data0]" time="0.0005500316619873047"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1253" name="test_execute_sql[load_iris_data0]" time="0.0005249977111816406"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1256" name="test_read_table[load_iris_data0]" time="0.0006146430969238281"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1260" name="test_read_table_columns[load_iris_data0]" time="0.0005626678466796875"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1266" name="test_read_table_absent_raises[load_iris_data0]" time="0.0006170272827148438"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1283" name="test_bigint[load_iris_data0]" time="0.0006451606750488281"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1291" name="test_default_date_load[load_iris_data0]" time="0.0011851787567138672"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1298" name="test_datetime_with_timezone[load_iris_data0]" time="0.0010671615600585938"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1369" name="test_datetime_with_timezone_roundtrip[load_iris_data0]" time="0.0006961822509765625"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1398" name="test_naive_datetimeindex_roundtrip[load_iris_data0]" time="0.0008800029754638672"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1409" name="test_date_parsing[load_iris_data0]" time="0.0005481243133544922"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1439" name="test_datetime[load_iris_data0]" time="0.0005352497100830078"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1459" name="test_datetime_NaT[load_iris_data0]" time="0.0006518363952636719"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1478" name="test_datetime_date[load_iris_data0]" time="0.0010132789611816406"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1488" name="test_datetime_time[load_iris_data0]" time="0.0029120445251464844"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1511" name="test_mixed_dtype_insert[load_iris_data0]" time="0.0006291866302490234"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1523" name="test_nan_numeric[load_iris_data0]" time="0.001516103744506836"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1536" name="test_nan_fullcolumn[load_iris_data0]" time="0.002136707305908203"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1551" name="test_nan_string[load_iris_data0]" time="0.001062154769897461"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1574" name="test_to_sql_save_index[load_iris_data0]" time="0.0010330677032470703"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1580" name="test_get_schema_create_table[load_iris_data0]" time="0.00119781494140625"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1597" name="test_dtype[load_iris_data0]" time="0.0010209083557128906"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1628" name="test_notna_dtype[load_iris_data0]" time="0.002042055130004883"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1653" name="test_double_precision[load_iris_data0]" time="0.0019021034240722656"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1681" name="test_connectable_issue_example[load_iris_data0]" time="0.0052950382232666016"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1703" name="test_temporary_table[load_iris_data0]" time="0.003080129623413086"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1731" name="test_transactions[load_iris_data0]" time="0.0009129047393798828"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1804" name="test_default_type_conversion[load_iris_data0]" time="0.0011191368103027344"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestMySQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1819" name="test_read_procedure[load_iris_data0]" time="0.00437474250793457"><error message="test setup failure">cls = &lt;pandas.tests.io.test_sql.TestMySQLAlchemyConn object at 0x1417b7f60&gt;

    @pytest.fixture(autouse=True, scope=&apos;class&apos;)
    def setup_class(cls):
        cls.setup_import()
        cls.setup_driver()
        conn = cls.connect()
&gt;       conn.connect()

pandas/tests/io/test_sql.py:1162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2102: in connect
    return self._connection_cls(self, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:90: in __init__
    if connection is not None else engine.raw_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2188: in raw_connection
    self.pool.unique_connection, _connection)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2162: in _wrap_pool_connect
    e, dialect, self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1476: in _handle_dbapi_exception_noconnection
    exc_info
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:265: in raise_from_cause
    reraise(type(exception), exception, tb=exc_tb, cause=cause)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:248: in reraise
    raise value.with_traceback(tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2158: in _wrap_pool_connect
    return fn()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:342: in unique_connection
    return _ConnectionFairy._checkout(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:788: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:529: in checkout
    rec = pool._do_get()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1193: in _do_get
    self._dec_overflow()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:66: in __exit__
    compat.reraise(exc_type, exc_value, exc_tb)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/util/compat.py:249: in reraise
    raise value
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:1190: in _do_get
    return self._create_connection()
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:347: in _create_connection
    return _ConnectionRecord(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:474: in __init__
    self.__connect(first_connect_check=True)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/pool.py:671: in __connect
    connection = pool._invoke_creator(self)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:106: in connect
    return dialect.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/sqlalchemy/engine/default.py:412: in connect
    return self.dbapi.connect(*cargs, **cparams)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect
    return Connection(*args, **kwargs)
../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:327: in __init__
    self.connect()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;pymysql.connections.Connection object at 0x1444d1438&gt;, sock = None

    def connect(self, sock=None):
        self._closed = False
        try:
            if sock is None:
                if self.unix_socket:
                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                    sock.settimeout(self.connect_timeout)
                    sock.connect(self.unix_socket)
                    self.host_info = &quot;Localhost via UNIX socket&quot;
                    self._secure = True
                    if DEBUG: print(&apos;connected using unix_socket&apos;)
                else:
                    kwargs = {}
                    if self.bind_address is not None:
                        kwargs[&apos;source_address&apos;] = (self.bind_address, 0)
                    while True:
                        try:
                            sock = socket.create_connection(
                                (self.host, self.port), self.connect_timeout,
                                **kwargs)
                            break
                        except (OSError, IOError) as e:
                            if e.errno == errno.EINTR:
                                continue
                            raise
                    self.host_info = &quot;socket %s:%d&quot; % (self.host, self.port)
                    if DEBUG: print(&apos;connected using socket&apos;)
                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
                sock.settimeout(None)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self._sock = sock
            self._rfile = _makefile(sock, &apos;rb&apos;)
            self._next_seq_id = 0
    
            self._get_server_information()
            self._request_authentication()
    
            if self.sql_mode is not None:
                c = self.cursor()
                c.execute(&quot;SET sql_mode=%s&quot;, (self.sql_mode,))
    
            if self.init_command is not None:
                c = self.cursor()
                c.execute(self.init_command)
                c.close()
                self.commit()
    
            if self.autocommit_mode is not None:
                self.autocommit(self.autocommit_mode)
        except BaseException as e:
            self._rfile = None
            if sock is not None:
                try:
                    sock.close()
                except:  # noqa
                    pass
    
            if isinstance(e, (OSError, IOError, socket.error)):
                exc = err.OperationalError(
                        2003,
                        &quot;Can&apos;t connect to MySQL server on %r (%s)&quot; % (
                            self.host, e))
                # Keep original exception and traceback to investigate error.
                exc.original_exception = e
                exc.traceback = traceback.format_exc()
                if DEBUG: print(exc.traceback)
&gt;               raise exc
E               sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2003, &quot;Can&apos;t connect to MySQL server on &apos;localhost&apos; ([Errno 61] Connection refused)&quot;) (Background on this error at: http://sqlalche.me/e/e3q8)

../../virtualenv/pandas-dev/lib/python3.7/site-packages/pymysql/connections.py:629: OperationalError</error></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1195" name="test_read_sql[load_iris_data0]" time="0.006195783615112305"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1198" name="test_read_sql_parameter[load_iris_data0]" time="0.002101898193359375"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1201" name="test_read_sql_named_parameter[load_iris_data0]" time="0.0011410713195800781"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1204" name="test_to_sql[load_iris_data0]" time="0.0010023117065429688"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1207" name="test_to_sql_empty[load_iris_data0]" time="0.0016987323760986328"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1210" name="test_to_sql_fail[load_iris_data0]" time="0.0015559196472167969"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1213" name="test_to_sql_replace[load_iris_data0]" time="0.00423431396484375"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1216" name="test_to_sql_append[load_iris_data0]" time="0.001260995864868164"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1219" name="test_to_sql_method_multi[load_iris_data0]" time="0.002045154571533203"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1222" name="test_to_sql_method_callable[load_iris_data0]" time="0.0012402534484863281"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1225" name="test_create_table[load_iris_data0]" time="0.0009222030639648438"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1235" name="test_drop_table[load_iris_data0]" time="0.001177072525024414"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1250" name="test_roundtrip[load_iris_data0]" time="0.0009629726409912109"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1253" name="test_execute_sql[load_iris_data0]" time="0.0024759769439697266"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1256" name="test_read_table[load_iris_data0]" time="0.0008025169372558594"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1260" name="test_read_table_columns[load_iris_data0]" time="0.0038580894470214844"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1266" name="test_read_table_absent_raises[load_iris_data0]" time="0.0017228126525878906"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1271" name="test_default_type_conversion[load_iris_data0]" time="0.0013587474822998047"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1283" name="test_bigint[load_iris_data0]" time="0.0010671615600585938"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1291" name="test_default_date_load[load_iris_data0]" time="0.001216888427734375"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1298" name="test_datetime_with_timezone[load_iris_data0]" time="0.0011506080627441406"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1369" name="test_datetime_with_timezone_roundtrip[load_iris_data0]" time="0.0013811588287353516"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1398" name="test_naive_datetimeindex_roundtrip[load_iris_data0]" time="0.0008797645568847656"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1409" name="test_date_parsing[load_iris_data0]" time="0.0009589195251464844"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1439" name="test_datetime[load_iris_data0]" time="0.0009100437164306641"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1459" name="test_datetime_NaT[load_iris_data0]" time="0.0009119510650634766"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1478" name="test_datetime_date[load_iris_data0]" time="0.0010952949523925781"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1488" name="test_datetime_time[load_iris_data0]" time="0.004805564880371094"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1511" name="test_mixed_dtype_insert[load_iris_data0]" time="0.0012831687927246094"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1523" name="test_nan_numeric[load_iris_data0]" time="0.0013997554779052734"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1536" name="test_nan_fullcolumn[load_iris_data0]" time="0.0012121200561523438"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1551" name="test_nan_string[load_iris_data0]" time="0.0018169879913330078"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1574" name="test_to_sql_save_index[load_iris_data0]" time="0.0006237030029296875"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1577" name="test_transactions[load_iris_data0]" time="0.0008089542388916016"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1580" name="test_get_schema_create_table[load_iris_data0]" time="0.0010411739349365234"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1597" name="test_dtype[load_iris_data0]" time="0.0014519691467285156"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1628" name="test_notna_dtype[load_iris_data0]" time="0.0008661746978759766"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1653" name="test_double_precision[load_iris_data0]" time="0.0008709430694580078"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1681" name="test_connectable_issue_example[load_iris_data0]" time="0.0011320114135742188"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1703" name="test_temporary_table[load_iris_data0]" time="0.0009062290191650391"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1868" name="test_schema_support[load_iris_data0]" time="0.0011219978332519531"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemy" file="pandas/tests/io/test_sql.py" line="1933" name="test_copy_from_callable_insertion_method[load_iris_data0]" time="0.0021469593048095703"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1195" name="test_read_sql[load_iris_data0]" time="0.002135038375854492"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1198" name="test_read_sql_parameter[load_iris_data0]" time="0.0006430149078369141"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1201" name="test_read_sql_named_parameter[load_iris_data0]" time="0.0013277530670166016"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1204" name="test_to_sql[load_iris_data0]" time="0.0008029937744140625"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1207" name="test_to_sql_empty[load_iris_data0]" time="0.0010178089141845703"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1210" name="test_to_sql_fail[load_iris_data0]" time="0.0008716583251953125"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1213" name="test_to_sql_replace[load_iris_data0]" time="0.0012431144714355469"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1216" name="test_to_sql_append[load_iris_data0]" time="0.001415252685546875"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1219" name="test_to_sql_method_multi[load_iris_data0]" time="0.0010640621185302734"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1222" name="test_to_sql_method_callable[load_iris_data0]" time="0.0010986328125"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1225" name="test_create_table[load_iris_data0]" time="0.0015957355499267578"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1235" name="test_drop_table[load_iris_data0]" time="0.0013091564178466797"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1250" name="test_roundtrip[load_iris_data0]" time="0.0008420944213867188"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1253" name="test_execute_sql[load_iris_data0]" time="0.006571769714355469"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1256" name="test_read_table[load_iris_data0]" time="0.007602691650390625"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1260" name="test_read_table_columns[load_iris_data0]" time="0.0023910999298095703"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1266" name="test_read_table_absent_raises[load_iris_data0]" time="0.0014150142669677734"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1271" name="test_default_type_conversion[load_iris_data0]" time="0.0009608268737792969"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1283" name="test_bigint[load_iris_data0]" time="0.0015003681182861328"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1291" name="test_default_date_load[load_iris_data0]" time="0.0009589195251464844"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1298" name="test_datetime_with_timezone[load_iris_data0]" time="0.002668142318725586"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1369" name="test_datetime_with_timezone_roundtrip[load_iris_data0]" time="0.0010764598846435547"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1398" name="test_naive_datetimeindex_roundtrip[load_iris_data0]" time="0.004769325256347656"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1409" name="test_date_parsing[load_iris_data0]" time="0.0009768009185791016"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1439" name="test_datetime[load_iris_data0]" time="0.005838871002197266"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1459" name="test_datetime_NaT[load_iris_data0]" time="0.0010800361633300781"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1478" name="test_datetime_date[load_iris_data0]" time="0.0018830299377441406"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1488" name="test_datetime_time[load_iris_data0]" time="0.0008459091186523438"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1511" name="test_mixed_dtype_insert[load_iris_data0]" time="0.0010480880737304688"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1523" name="test_nan_numeric[load_iris_data0]" time="0.0011458396911621094"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1536" name="test_nan_fullcolumn[load_iris_data0]" time="0.0012941360473632812"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1551" name="test_nan_string[load_iris_data0]" time="0.0030171871185302734"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1574" name="test_to_sql_save_index[load_iris_data0]" time="0.000965118408203125"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1580" name="test_get_schema_create_table[load_iris_data0]" time="0.0013914108276367188"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1597" name="test_dtype[load_iris_data0]" time="0.0064220428466796875"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1628" name="test_notna_dtype[load_iris_data0]" time="0.0013608932495117188"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1653" name="test_double_precision[load_iris_data0]" time="0.001071929931640625"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1681" name="test_connectable_issue_example[load_iris_data0]" time="0.00086212158203125"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1703" name="test_temporary_table[load_iris_data0]" time="0.0013432502746582031"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1731" name="test_transactions[load_iris_data0]" time="0.0013458728790283203"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1868" name="test_schema_support[load_iris_data0]" time="0.0010263919830322266"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestPostgreSQLAlchemyConn" file="pandas/tests/io/test_sql.py" line="1933" name="test_copy_from_callable_insertion_method[load_iris_data0]" time="0.004542827606201172"><skipped message="could not import &apos;psycopg2&apos;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1866: could not import &apos;psycopg2&apos;</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1195" name="test_read_sql[load_iris_data0]" time="0.10185813903808594"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1198" name="test_read_sql_parameter[load_iris_data0]" time="0.07822108268737793"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1201" name="test_read_sql_named_parameter[load_iris_data0]" time="0.06824207305908203"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1204" name="test_to_sql[load_iris_data0]" time="0.04623818397521973"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1207" name="test_to_sql_empty[load_iris_data0]" time="0.0675666332244873"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1210" name="test_to_sql_fail[load_iris_data0]" time="0.14051556587219238"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1213" name="test_to_sql_replace[load_iris_data0]" time="0.14879775047302246"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1216" name="test_to_sql_append[load_iris_data0]" time="0.22113990783691406"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1219" name="test_to_sql_method_multi[load_iris_data0]" time="0.10019993782043457"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1222" name="test_to_sql_method_callable[load_iris_data0]" time="0.10480666160583496"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1225" name="test_create_table[load_iris_data0]" time="0.07856035232543945"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1235" name="test_drop_table[load_iris_data0]" time="0.12545204162597656"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1250" name="test_roundtrip[load_iris_data0]" time="0.19287991523742676"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1253" name="test_execute_sql[load_iris_data0]" time="0.1504678726196289"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1256" name="test_read_table[load_iris_data0]" time="0.18695616722106934"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1260" name="test_read_table_columns[load_iris_data0]" time="0.0622553825378418"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1266" name="test_read_table_absent_raises[load_iris_data0]" time="0.043123722076416016"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1283" name="test_bigint[load_iris_data0]" time="0.0965111255645752"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1298" name="test_datetime_with_timezone[load_iris_data0]" time="0.11305713653564453"><skipped message="no column with datetime with time zone" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1337: no column with datetime with time zone</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1369" name="test_datetime_with_timezone_roundtrip[load_iris_data0]" time="0.26598620414733887"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1398" name="test_naive_datetimeindex_roundtrip[load_iris_data0]" time="0.13470005989074707"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1409" name="test_date_parsing[load_iris_data0]" time="0.12024807929992676"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1439" name="test_datetime[load_iris_data0]" time="0.1425457000732422"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1459" name="test_datetime_NaT[load_iris_data0]" time="0.1301107406616211"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1478" name="test_datetime_date[load_iris_data0]" time="0.08763933181762695"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1488" name="test_datetime_time[load_iris_data0]" time="0.07037782669067383"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1511" name="test_mixed_dtype_insert[load_iris_data0]" time="0.052353620529174805"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1523" name="test_nan_numeric[load_iris_data0]" time="0.04414677619934082"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1536" name="test_nan_fullcolumn[load_iris_data0]" time="0.04389381408691406"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1551" name="test_nan_string[load_iris_data0]" time="0.05105018615722656"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1574" name="test_to_sql_save_index[load_iris_data0]" time="0.08210134506225586"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1577" name="test_transactions[load_iris_data0]" time="0.14917850494384766"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1580" name="test_get_schema_create_table[load_iris_data0]" time="0.08244514465332031"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1597" name="test_dtype[load_iris_data0]" time="0.10260701179504395"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1628" name="test_notna_dtype[load_iris_data0]" time="0.16473984718322754"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1653" name="test_double_precision[load_iris_data0]" time="0.12331080436706543"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1681" name="test_connectable_issue_example[load_iris_data0]" time="0.12460756301879883"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1703" name="test_temporary_table[load_iris_data0]" time="0.11762785911560059"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1752" name="test_default_type_conversion[load_iris_data0]" time="0.07507634162902832"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1767" name="test_default_date_load[load_iris_data0]" time="0.044863224029541016"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemy" file="pandas/tests/io/test_sql.py" line="1773" name="test_bigint_warning[load_iris_data0]" time="0.0519404411315918"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1195" name="test_read_sql[load_iris_data0]" time="0.05498814582824707"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1198" name="test_read_sql_parameter[load_iris_data0]" time="0.1095890998840332"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1201" name="test_read_sql_named_parameter[load_iris_data0]" time="0.09620499610900879"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1204" name="test_to_sql[load_iris_data0]" time="0.10113191604614258"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1207" name="test_to_sql_empty[load_iris_data0]" time="0.0962522029876709"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1210" name="test_to_sql_fail[load_iris_data0]" time="0.13055205345153809"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1213" name="test_to_sql_replace[load_iris_data0]" time="0.10863423347473145"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1216" name="test_to_sql_append[load_iris_data0]" time="0.12236833572387695"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1219" name="test_to_sql_method_multi[load_iris_data0]" time="0.07610297203063965"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1222" name="test_to_sql_method_callable[load_iris_data0]" time="0.19701695442199707"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1225" name="test_create_table[load_iris_data0]" time="0.03689694404602051"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1235" name="test_drop_table[load_iris_data0]" time="0.03608298301696777"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1250" name="test_roundtrip[load_iris_data0]" time="0.050646066665649414"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1253" name="test_execute_sql[load_iris_data0]" time="0.039972782135009766"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1256" name="test_read_table[load_iris_data0]" time="0.1258378028869629"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1260" name="test_read_table_columns[load_iris_data0]" time="0.11866259574890137"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1266" name="test_read_table_absent_raises[load_iris_data0]" time="0.07998394966125488"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1283" name="test_bigint[load_iris_data0]" time="0.06071662902832031"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1298" name="test_datetime_with_timezone[load_iris_data0]" time="0.04637432098388672"><skipped message="no column with datetime with time zone" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1337: no column with datetime with time zone</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1369" name="test_datetime_with_timezone_roundtrip[load_iris_data0]" time="0.045784950256347656"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1398" name="test_naive_datetimeindex_roundtrip[load_iris_data0]" time="0.07365822792053223"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1409" name="test_date_parsing[load_iris_data0]" time="0.13051271438598633"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1439" name="test_datetime[load_iris_data0]" time="0.05186915397644043"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1459" name="test_datetime_NaT[load_iris_data0]" time="0.05332803726196289"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1478" name="test_datetime_date[load_iris_data0]" time="0.10654592514038086"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1488" name="test_datetime_time[load_iris_data0]" time="0.13422918319702148"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1511" name="test_mixed_dtype_insert[load_iris_data0]" time="0.04854083061218262"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1523" name="test_nan_numeric[load_iris_data0]" time="0.048269033432006836"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1536" name="test_nan_fullcolumn[load_iris_data0]" time="0.10455942153930664"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1551" name="test_nan_string[load_iris_data0]" time="0.10340428352355957"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1574" name="test_to_sql_save_index[load_iris_data0]" time="0.07239627838134766"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1580" name="test_get_schema_create_table[load_iris_data0]" time="0.07032918930053711"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1597" name="test_dtype[load_iris_data0]" time="0.10529780387878418"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1628" name="test_notna_dtype[load_iris_data0]" time="0.09649920463562012"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1653" name="test_double_precision[load_iris_data0]" time="0.05928182601928711"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1681" name="test_connectable_issue_example[load_iris_data0]" time="0.03614616394042969"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1703" name="test_temporary_table[load_iris_data0]" time="0.032883405685424805"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1731" name="test_transactions[load_iris_data0]" time="0.03348517417907715"><skipped message="Nested transactions rollbacks don&apos;t work with Pandas" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:1734: Nested transactions rollbacks don&apos;t work with Pandas</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1752" name="test_default_type_conversion[load_iris_data0]" time="0.035970211029052734"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1767" name="test_default_date_load[load_iris_data0]" time="0.04170799255371094"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteAlchemyConn" file="pandas/tests/io/test_sql.py" line="1773" name="test_bigint_warning[load_iris_data0]" time="0.08970880508422852"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2024" name="test_read_sql[load_iris_data0]" time="0.01737499237060547"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2027" name="test_read_sql_parameter[load_iris_data0]" time="0.02323317527770996"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2030" name="test_read_sql_named_parameter[load_iris_data0]" time="0.020461559295654297"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2033" name="test_to_sql[load_iris_data0]" time="0.01918482780456543"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2036" name="test_to_sql_empty[load_iris_data0]" time="0.018659591674804688"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2039" name="test_to_sql_fail[load_iris_data0]" time="0.02439737319946289"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2042" name="test_to_sql_replace[load_iris_data0]" time="0.02556920051574707"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2045" name="test_to_sql_append[load_iris_data0]" time="0.023381710052490234"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2048" name="test_create_and_drop_table[load_iris_data0]" time="0.019793033599853516"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2060" name="test_roundtrip[load_iris_data0]" time="0.03069019317626953"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2063" name="test_execute_sql[load_iris_data0]" time="0.011192083358764648"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2066" name="test_datetime_date[load_iris_data0]" time="0.018039464950561523"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2077" name="test_datetime_time[load_iris_data0]" time="0.028583288192749023"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2098" name="test_to_sql_save_index[load_iris_data0]" time="0.03631186485290527"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2101" name="test_transactions[load_iris_data0]" time="0.018338441848754883"><skipped message="not working on python &gt; 3.5" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/tests/io/test_sql.py:2104: not working on python &gt; 3.5</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2113" name="test_dtype[load_iris_data0]" time="0.03413128852844238"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2140" name="test_notna_dtype[load_iris_data0]" time="0.024754047393798828"></testcase><testcase classname="pandas.tests.io.test_sql.TestSQLiteFallback" file="pandas/tests/io/test_sql.py" line="2159" name="test_illegal_names[load_iris_data0]" time="0.09506988525390625"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2241" name="test_basic" time="0.04597043991088867"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2245" name="test_write_row_by_row" time="0.052809953689575195"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2266" name="test_execute" time="0.02647089958190918"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2281" name="test_schema" time="0.04365658760070801"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2297" name="test_execute_fail" time="0.005913734436035156"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2316" name="test_execute_closed_connection" time="0.005084514617919922"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2335" name="test_na_roundtrip" time="0.005560874938964844"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2359" name="test_keyword_as_column_names" time="0.006835222244262695"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2363" name="test_onecolumn_of_integer" time="0.010532379150390625"></testcase><testcase classname="pandas.tests.io.test_sql.TestXSQLite" file="pandas/tests/io/test_sql.py" line="2379" name="test_if_exists" time="0.026073455810546875"></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2473" name="test_basic" time="0.00039386749267578125"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2473: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2477" name="test_write_row_by_row" time="0.0002918243408203125"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2477: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2496" name="test_chunksize_read_type" time="0.000888824462890625"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2496: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2510" name="test_execute" time="0.0046918392181396484"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2510: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2529" name="test_schema" time="0.0005440711975097656"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2529: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2547" name="test_execute_fail" time="0.0005080699920654297"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2547: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2568" name="test_execute_closed_connection" time="0.0004642009735107422"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2568: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2592" name="test_na_roundtrip" time="0.0005948543548583984"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2592: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2631" name="test_keyword_as_column_names" time="0.0010759830474853516"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2631: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.test_sql.TestXMySQL" file="pandas/tests/io/test_sql.py" line="2636" name="test_if_exists" time="0.0008740425109863281"><skipped message="gh-13611: there is no support for MySQL if SQLAlchemy is not installed" type="pytest.skip">pandas/tests/io/test_sql.py:2636: gh-13611: there is no support for MySQL if SQLAlchemy is not installed</skipped></testcase><testcase classname="pandas.tests.io.json.test_pandas.TestPandasContainer" file="pandas/tests/io/json/test_pandas.py" line="870" name="test_round_trip_exception_" time="75.76170182228088"><skipped message="Skipping test because exception message is known and error &lt;urlopen error [Errno 60] Operation timed out&gt;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/util/testing.py:2208: Skipping test because exception message is known and error &lt;urlopen error [Errno 60] Operation timed out&gt;</skipped></testcase><testcase classname="pandas.tests.io.json.test_pandas.TestPandasContainer" file="pandas/tests/io/json/test_pandas.py" line="881" name="test_url" time="75.6357159614563"><skipped message="Skipping test because exception message is known and error &lt;urlopen error [Errno 60] Operation timed out&gt;" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/util/testing.py:2208: Skipping test because exception message is known and error &lt;urlopen error [Errno 60] Operation timed out&gt;</skipped></testcase><testcase classname="pandas.tests.series.test_rank" file="pandas/tests/series/test_rank.py" line="494" name="test_pct_max_many_rows" time="0.07415294647216797"><skipped message="skipping high memory test since --run-high-memory was not set" type="pytest.skip">/Users/bhavani/apps/pandas/pandas/conftest.py:61: skipping high memory test since --run-high-memory was not set</skipped></testcase></testsuite>